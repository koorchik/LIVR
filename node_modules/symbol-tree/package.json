{
  "_args": [
    [
      {
        "raw": "symbol-tree@>= 3.1.0 < 4.0.0",
        "scope": null,
        "escapedName": "symbol-tree",
        "name": "symbol-tree",
        "rawSpec": ">= 3.1.0 < 4.0.0",
        "spec": ">=3.1.0 <4.0.0",
        "type": "range"
      },
      "/home/vera/Documents/LIVR/node_modules/jsdom"
    ]
  ],
  "_from": "symbol-tree@>=3.1.0 <4.0.0",
  "_id": "symbol-tree@3.2.2",
  "_inCache": true,
  "_location": "/symbol-tree",
  "_nodeVersion": "7.2.1",
  "_npmOperationalInternal": {
    "host": "packages-18-east.internal.npmjs.com",
    "tmp": "tmp/symbol-tree-3.2.2.tgz_1486847058094_0.6699730809777975"
  },
  "_npmUser": {
    "name": "joris-van-der-wel",
    "email": "joris@jorisvanderwel.com"
  },
  "_npmVersion": "3.10.10",
  "_phantomChildren": {},
  "_requested": {
    "raw": "symbol-tree@>= 3.1.0 < 4.0.0",
    "scope": null,
    "escapedName": "symbol-tree",
    "name": "symbol-tree",
    "rawSpec": ">= 3.1.0 < 4.0.0",
    "spec": ">=3.1.0 <4.0.0",
    "type": "range"
  },
  "_requiredBy": [
    "/jsdom"
  ],
  "_resolved": "https://registry.npmjs.org/symbol-tree/-/symbol-tree-3.2.2.tgz",
  "_shasum": "ae27db38f660a7ae2e1c3b7d1bc290819b8519e6",
  "_shrinkwrap": null,
  "_spec": "symbol-tree@>= 3.1.0 < 4.0.0",
  "_where": "/home/vera/Documents/LIVR/node_modules/jsdom",
  "author": {
    "name": "Joris van der Wel",
    "email": "joris@jorisvanderwel.com"
  },
  "bugs": {
    "url": "https://github.com/jsdom/js-symbol-tree/issues"
  },
  "dependencies": {},
  "description": "Turn any collection of objects into its own efficient tree or linked list using Symbol",
  "devDependencies": {
    "babel-eslint": "^7.1.1",
    "coveralls": "^2.11.15",
    "eslint": "^3.12.0",
    "eslint-plugin-import": "^2.2.0",
    "istanbul": "^0.4.5",
    "jsdoc-to-markdown": "^3.0.0",
    "tape": "^4.0.0"
  },
  "directories": {},
  "dist": {
    "shasum": "ae27db38f660a7ae2e1c3b7d1bc290819b8519e6",
    "tarball": "https://registry.npmjs.org/symbol-tree/-/symbol-tree-3.2.2.tgz"
  },
  "files": [
    "lib",
    "api.md"
  ],
  "gitHead": "1e213a3f820f79c083859cce601ed091154449b5",
  "homepage": "https://github.com/jsdom/js-symbol-tree#symbol-tree",
  "keywords": [
    "list",
    "queue",
    "stack",
    "linked-list",
    "tree",
    "es6",
    "dom",
    "symbol"
  ],
  "license": "MIT",
  "main": "lib/SymbolTree.js",
  "maintainers": [
    {
      "name": "joris-van-der-wel",
      "email": "joris@jorisvanderwel.com"
    }
  ],
  "name": "symbol-tree",
  "optionalDependencies": {},
  "readme": "symbol-tree\n===========\n[![Travis CI Build Status](https://api.travis-ci.org/jsdom/js-symbol-tree.svg?branch=master)](https://travis-ci.org/jsdom/js-symbol-tree) [![Coverage Status](https://coveralls.io/repos/github/jsdom/js-symbol-tree/badge.svg?branch=master)](https://coveralls.io/github/jsdom/js-symbol-tree?branch=master)\n\nTurn any collection of objects into its own efficient tree or linked list using `Symbol`.\n\nThis library has been designed to provide an efficient backing data structure for DOM trees. You can also use this library as an efficient linked list. Any meta data is stored on your objects directly, which ensures any kind of insertion or deletion is performed in constant time. Because an ES6 `Symbol` is used, the meta data does not interfere with your object in any way.\n\nNode.js 4+, io.js and modern browsers are supported.\n\nExample\n-------\nA linked list:\n\n```javascript\nconst SymbolTree = require('symbol-tree');\nconst tree = new SymbolTree();\n\nlet a = {foo: 'bar'}; // or `new Whatever()`\nlet b = {foo: 'baz'};\nlet c = {foo: 'qux'};\n\ntree.insertBefore(b, a); // insert a before b\ntree.insertAfter(b, c); // insert c after b\n\nconsole.log(tree.nextSibling(a) === b);\nconsole.log(tree.nextSibling(b) === c);\nconsole.log(tree.previousSibling(c) === b);\n\ntree.remove(b);\nconsole.log(tree.nextSibling(a) === c);\n```\n\nA tree:\n\n```javascript\nconst SymbolTree = require('symbol-tree');\nconst tree = new SymbolTree();\n\nlet parent = {};\nlet a = {};\nlet b = {};\nlet c = {};\n\ntree.prependChild(parent, a); // insert a as the first child\ntree.appendChild(parent,c ); // insert c as the last child\ntree.insertAfter(a, b); // insert b after a, it now has the same parent as a\n\nconsole.log(tree.firstChild(parent) === a);\nconsole.log(tree.nextSibling(tree.firstChild(parent)) === b);\nconsole.log(tree.lastChild(parent) === c);\n\nlet grandparent = {};\ntree.prependChild(grandparent, parent);\nconsole.log(tree.firstChild(tree.firstChild(grandparent)) === a);\n```\n\nTesting\n-------\nMake sure you install the dependencies first:\n\n    npm install\n\nYou can now run the unit tests by executing:\n\n    npm test\n\nThe line and branch coverage should be 100%.\n\nAPI Documentation\n-----------------\n<a name=\"module_symbol-tree\"></a>\n\n## symbol-tree\n**Author:** Joris van der Wel <joris@jorisvanderwel.com>\n\n* [symbol-tree](#module_symbol-tree)\n    * [SymbolTree](#exp_module_symbol-tree--SymbolTree) ⏏\n        * [new SymbolTree([description])](#new_module_symbol-tree--SymbolTree_new)\n        * [.initialize(object)](#module_symbol-tree--SymbolTree+initialize) ⇒ <code>Object</code>\n        * [.hasChildren(object)](#module_symbol-tree--SymbolTree+hasChildren) ⇒ <code>Boolean</code>\n        * [.firstChild(object)](#module_symbol-tree--SymbolTree+firstChild) ⇒ <code>Object</code>\n        * [.lastChild(object)](#module_symbol-tree--SymbolTree+lastChild) ⇒ <code>Object</code>\n        * [.previousSibling(object)](#module_symbol-tree--SymbolTree+previousSibling) ⇒ <code>Object</code>\n        * [.nextSibling(object)](#module_symbol-tree--SymbolTree+nextSibling) ⇒ <code>Object</code>\n        * [.parent(object)](#module_symbol-tree--SymbolTree+parent) ⇒ <code>Object</code>\n        * [.lastInclusiveDescendant(object)](#module_symbol-tree--SymbolTree+lastInclusiveDescendant) ⇒ <code>Object</code>\n        * [.preceding(object, [options])](#module_symbol-tree--SymbolTree+preceding) ⇒ <code>Object</code>\n        * [.following(object, [options])](#module_symbol-tree--SymbolTree+following) ⇒ <code>Object</code>\n        * [.childrenToArray(parent, [options])](#module_symbol-tree--SymbolTree+childrenToArray) ⇒ <code>Array.&lt;Object&gt;</code>\n        * [.ancestorsToArray(object, [options])](#module_symbol-tree--SymbolTree+ancestorsToArray) ⇒ <code>Array.&lt;Object&gt;</code>\n        * [.treeToArray(root, [options])](#module_symbol-tree--SymbolTree+treeToArray) ⇒ <code>Array.&lt;Object&gt;</code>\n        * [.childrenIterator(parent, [options])](#module_symbol-tree--SymbolTree+childrenIterator) ⇒ <code>Object</code>\n        * [.previousSiblingsIterator(object)](#module_symbol-tree--SymbolTree+previousSiblingsIterator) ⇒ <code>Object</code>\n        * [.nextSiblingsIterator(object)](#module_symbol-tree--SymbolTree+nextSiblingsIterator) ⇒ <code>Object</code>\n        * [.ancestorsIterator(object)](#module_symbol-tree--SymbolTree+ancestorsIterator) ⇒ <code>Object</code>\n        * [.treeIterator(root, options)](#module_symbol-tree--SymbolTree+treeIterator) ⇒ <code>Object</code>\n        * [.index(child)](#module_symbol-tree--SymbolTree+index) ⇒ <code>Number</code>\n        * [.childrenCount(parent)](#module_symbol-tree--SymbolTree+childrenCount) ⇒ <code>Number</code>\n        * [.compareTreePosition(left, right)](#module_symbol-tree--SymbolTree+compareTreePosition) ⇒ <code>Number</code>\n        * [.remove(removeObject)](#module_symbol-tree--SymbolTree+remove) ⇒ <code>Object</code>\n        * [.insertBefore(referenceObject, newObject)](#module_symbol-tree--SymbolTree+insertBefore) ⇒ <code>Object</code>\n        * [.insertAfter(referenceObject, newObject)](#module_symbol-tree--SymbolTree+insertAfter) ⇒ <code>Object</code>\n        * [.prependChild(referenceObject, newObject)](#module_symbol-tree--SymbolTree+prependChild) ⇒ <code>Object</code>\n        * [.appendChild(referenceObject, newObject)](#module_symbol-tree--SymbolTree+appendChild) ⇒ <code>Object</code>\n\n<a name=\"exp_module_symbol-tree--SymbolTree\"></a>\n\n### SymbolTree ⏏\n**Kind**: Exported class\n<a name=\"new_module_symbol-tree--SymbolTree_new\"></a>\n\n#### new SymbolTree([description])\n\n| Param | Type | Default | Description |\n| --- | --- | --- | --- |\n| [description] | <code>string</code> | <code>&quot;&#x27;SymbolTree data&#x27;&quot;</code> | Description used for the Symbol |\n\n<a name=\"module_symbol-tree--SymbolTree+initialize\"></a>\n\n#### symbolTree.initialize(object) ⇒ <code>Object</code>\nYou can use this function to (optionally) initialize an object right after its creation,\nto take advantage of V8's fast properties. Also useful if you would like to\nfreeze your object.\n\n`O(1)`\n\n**Kind**: instance method of <code>[SymbolTree](#exp_module_symbol-tree--SymbolTree)</code>\n**Returns**: <code>Object</code> - object\n\n| Param | Type |\n| --- | --- |\n| object | <code>Object</code> |\n\n<a name=\"module_symbol-tree--SymbolTree+hasChildren\"></a>\n\n#### symbolTree.hasChildren(object) ⇒ <code>Boolean</code>\nReturns `true` if the object has any children. Otherwise it returns `false`.\n\n* `O(1)`\n\n**Kind**: instance method of <code>[SymbolTree](#exp_module_symbol-tree--SymbolTree)</code>\n\n| Param | Type |\n| --- | --- |\n| object | <code>Object</code> |\n\n<a name=\"module_symbol-tree--SymbolTree+firstChild\"></a>\n\n#### symbolTree.firstChild(object) ⇒ <code>Object</code>\nReturns the first child of the given object.\n\n* `O(1)`\n\n**Kind**: instance method of <code>[SymbolTree](#exp_module_symbol-tree--SymbolTree)</code>\n\n| Param | Type |\n| --- | --- |\n| object | <code>Object</code> |\n\n<a name=\"module_symbol-tree--SymbolTree+lastChild\"></a>\n\n#### symbolTree.lastChild(object) ⇒ <code>Object</code>\nReturns the last child of the given object.\n\n* `O(1)`\n\n**Kind**: instance method of <code>[SymbolTree](#exp_module_symbol-tree--SymbolTree)</code>\n\n| Param | Type |\n| --- | --- |\n| object | <code>Object</code> |\n\n<a name=\"module_symbol-tree--SymbolTree+previousSibling\"></a>\n\n#### symbolTree.previousSibling(object) ⇒ <code>Object</code>\nReturns the previous sibling of the given object.\n\n* `O(1)`\n\n**Kind**: instance method of <code>[SymbolTree](#exp_module_symbol-tree--SymbolTree)</code>\n\n| Param | Type |\n| --- | --- |\n| object | <code>Object</code> |\n\n<a name=\"module_symbol-tree--SymbolTree+nextSibling\"></a>\n\n#### symbolTree.nextSibling(object) ⇒ <code>Object</code>\nReturns the next sibling of the given object.\n\n* `O(1)`\n\n**Kind**: instance method of <code>[SymbolTree](#exp_module_symbol-tree--SymbolTree)</code>\n\n| Param | Type |\n| --- | --- |\n| object | <code>Object</code> |\n\n<a name=\"module_symbol-tree--SymbolTree+parent\"></a>\n\n#### symbolTree.parent(object) ⇒ <code>Object</code>\nReturn the parent of the given object.\n\n* `O(1)`\n\n**Kind**: instance method of <code>[SymbolTree](#exp_module_symbol-tree--SymbolTree)</code>\n\n| Param | Type |\n| --- | --- |\n| object | <code>Object</code> |\n\n<a name=\"module_symbol-tree--SymbolTree+lastInclusiveDescendant\"></a>\n\n#### symbolTree.lastInclusiveDescendant(object) ⇒ <code>Object</code>\nFind the inclusive descendant that is last in tree order of the given object.\n\n* `O(n)` (worst case) where `n` is the depth of the subtree of `object`\n\n**Kind**: instance method of <code>[SymbolTree](#exp_module_symbol-tree--SymbolTree)</code>\n\n| Param | Type |\n| --- | --- |\n| object | <code>Object</code> |\n\n<a name=\"module_symbol-tree--SymbolTree+preceding\"></a>\n\n#### symbolTree.preceding(object, [options]) ⇒ <code>Object</code>\nFind the preceding object (A) of the given object (B).\nAn object A is preceding an object B if A and B are in the same tree\nand A comes before B in tree order.\n\n* `O(n)` (worst case)\n* `O(1)` (amortized when walking the entire tree)\n\n**Kind**: instance method of <code>[SymbolTree](#exp_module_symbol-tree--SymbolTree)</code>\n\n| Param | Type | Description |\n| --- | --- | --- |\n| object | <code>Object</code> |  |\n| [options] | <code>Object</code> |  |\n| [options.root] | <code>Object</code> | If set, `root` must be an inclusive ancestor        of the return value (or else null is returned). This check _assumes_        that `root` is also an inclusive ancestor of the given `object` |\n\n<a name=\"module_symbol-tree--SymbolTree+following\"></a>\n\n#### symbolTree.following(object, [options]) ⇒ <code>Object</code>\nFind the following object (A) of the given object (B).\nAn object A is following an object B if A and B are in the same tree\nand A comes after B in tree order.\n\n* `O(n)` (worst case) where `n` is the amount of objects in the entire tree\n* `O(1)` (amortized when walking the entire tree)\n\n**Kind**: instance method of <code>[SymbolTree](#exp_module_symbol-tree--SymbolTree)</code>\n\n| Param | Type | Default | Description |\n| --- | --- | --- | --- |\n| object | <code>Object</code> |  |  |\n| [options] | <code>Object</code> |  |  |\n| [options.root] | <code>Object</code> |  | If set, `root` must be an inclusive ancestor        of the return value (or else null is returned). This check _assumes_        that `root` is also an inclusive ancestor of the given `object` |\n| [options.skipChildren] | <code>Boolean</code> | <code>false</code> | If set, ignore the children of `object` |\n\n<a name=\"module_symbol-tree--SymbolTree+childrenToArray\"></a>\n\n#### symbolTree.childrenToArray(parent, [options]) ⇒ <code>Array.&lt;Object&gt;</code>\nAppend all children of the given object to an array.\n\n* `O(n)` where `n` is the amount of children of the given `parent`\n\n**Kind**: instance method of <code>[SymbolTree](#exp_module_symbol-tree--SymbolTree)</code>\n\n| Param | Type | Default | Description |\n| --- | --- | --- | --- |\n| parent | <code>Object</code> |  |  |\n| [options] | <code>Object</code> |  |  |\n| [options.array] | <code>Array.&lt;Object&gt;</code> | <code>[]</code> |  |\n| [options.filter] | <code>function</code> |  | Function to test each object before it is added to the array.                            Invoked with arguments (object). Should return `true` if an object                            is to be included. |\n| [options.thisArg] | <code>\\*</code> |  | Value to use as `this` when executing `filter`. |\n\n<a name=\"module_symbol-tree--SymbolTree+ancestorsToArray\"></a>\n\n#### symbolTree.ancestorsToArray(object, [options]) ⇒ <code>Array.&lt;Object&gt;</code>\nAppend all inclusive ancestors of the given object to an array.\n\n* `O(n)` where `n` is the amount of ancestors of the given `object`\n\n**Kind**: instance method of <code>[SymbolTree](#exp_module_symbol-tree--SymbolTree)</code>\n\n| Param | Type | Default | Description |\n| --- | --- | --- | --- |\n| object | <code>Object</code> |  |  |\n| [options] | <code>Object</code> |  |  |\n| [options.array] | <code>Array.&lt;Object&gt;</code> | <code>[]</code> |  |\n| [options.filter] | <code>function</code> |  | Function to test each object before it is added to the array.                            Invoked with arguments (object). Should return `true` if an object                            is to be included. |\n| [options.thisArg] | <code>\\*</code> |  | Value to use as `this` when executing `filter`. |\n\n<a name=\"module_symbol-tree--SymbolTree+treeToArray\"></a>\n\n#### symbolTree.treeToArray(root, [options]) ⇒ <code>Array.&lt;Object&gt;</code>\nAppend all descendants of the given object to an array (in tree order).\n\n* `O(n)` where `n` is the amount of objects in the sub-tree of the given `object`\n\n**Kind**: instance method of <code>[SymbolTree](#exp_module_symbol-tree--SymbolTree)</code>\n\n| Param | Type | Default | Description |\n| --- | --- | --- | --- |\n| root | <code>Object</code> |  |  |\n| [options] | <code>Object</code> |  |  |\n| [options.array] | <code>Array.&lt;Object&gt;</code> | <code>[]</code> |  |\n| [options.filter] | <code>function</code> |  | Function to test each object before it is added to the array.                            Invoked with arguments (object). Should return `true` if an object                            is to be included. |\n| [options.thisArg] | <code>\\*</code> |  | Value to use as `this` when executing `filter`. |\n\n<a name=\"module_symbol-tree--SymbolTree+childrenIterator\"></a>\n\n#### symbolTree.childrenIterator(parent, [options]) ⇒ <code>Object</code>\nIterate over all children of the given object\n\n* `O(1)` for a single iteration\n\n**Kind**: instance method of <code>[SymbolTree](#exp_module_symbol-tree--SymbolTree)</code>\n**Returns**: <code>Object</code> - An iterable iterator (ES6)\n\n| Param | Type | Default |\n| --- | --- | --- |\n| parent | <code>Object</code> |  |\n| [options] | <code>Object</code> |  |\n| [options.reverse] | <code>Boolean</code> | <code>false</code> |\n\n<a name=\"module_symbol-tree--SymbolTree+previousSiblingsIterator\"></a>\n\n#### symbolTree.previousSiblingsIterator(object) ⇒ <code>Object</code>\nIterate over all the previous siblings of the given object. (in reverse tree order)\n\n* `O(1)` for a single iteration\n\n**Kind**: instance method of <code>[SymbolTree](#exp_module_symbol-tree--SymbolTree)</code>\n**Returns**: <code>Object</code> - An iterable iterator (ES6)\n\n| Param | Type |\n| --- | --- |\n| object | <code>Object</code> |\n\n<a name=\"module_symbol-tree--SymbolTree+nextSiblingsIterator\"></a>\n\n#### symbolTree.nextSiblingsIterator(object) ⇒ <code>Object</code>\nIterate over all the next siblings of the given object. (in tree order)\n\n* `O(1)` for a single iteration\n\n**Kind**: instance method of <code>[SymbolTree](#exp_module_symbol-tree--SymbolTree)</code>\n**Returns**: <code>Object</code> - An iterable iterator (ES6)\n\n| Param | Type |\n| --- | --- |\n| object | <code>Object</code> |\n\n<a name=\"module_symbol-tree--SymbolTree+ancestorsIterator\"></a>\n\n#### symbolTree.ancestorsIterator(object) ⇒ <code>Object</code>\nIterate over all inclusive ancestors of the given object\n\n* `O(1)` for a single iteration\n\n**Kind**: instance method of <code>[SymbolTree](#exp_module_symbol-tree--SymbolTree)</code>\n**Returns**: <code>Object</code> - An iterable iterator (ES6)\n\n| Param | Type |\n| --- | --- |\n| object | <code>Object</code> |\n\n<a name=\"module_symbol-tree--SymbolTree+treeIterator\"></a>\n\n#### symbolTree.treeIterator(root, options) ⇒ <code>Object</code>\nIterate over all descendants of the given object (in tree order).\n\nWhere `n` is the amount of objects in the sub-tree of the given `root`:\n\n* `O(n)` (worst case for a single iteration)\n* `O(n)` (amortized, when completing the iterator)\n\n**Kind**: instance method of <code>[SymbolTree](#exp_module_symbol-tree--SymbolTree)</code>\n**Returns**: <code>Object</code> - An iterable iterator (ES6)\n\n| Param | Type | Default |\n| --- | --- | --- |\n| root | <code>Object</code> |  |\n| options | <code>Object</code> |  |\n| [options.reverse] | <code>Boolean</code> | <code>false</code> |\n\n<a name=\"module_symbol-tree--SymbolTree+index\"></a>\n\n#### symbolTree.index(child) ⇒ <code>Number</code>\nFind the index of the given object (the number of preceding siblings).\n\n* `O(n)` where `n` is the amount of preceding siblings\n* `O(1)` (amortized, if the tree is not modified)\n\n**Kind**: instance method of <code>[SymbolTree](#exp_module_symbol-tree--SymbolTree)</code>\n**Returns**: <code>Number</code> - The number of preceding siblings, or -1 if the object has no parent\n\n| Param | Type |\n| --- | --- |\n| child | <code>Object</code> |\n\n<a name=\"module_symbol-tree--SymbolTree+childrenCount\"></a>\n\n#### symbolTree.childrenCount(parent) ⇒ <code>Number</code>\nCalculate the number of children.\n\n* `O(n)` where `n` is the amount of children\n* `O(1)` (amortized, if the tree is not modified)\n\n**Kind**: instance method of <code>[SymbolTree](#exp_module_symbol-tree--SymbolTree)</code>\n\n| Param | Type |\n| --- | --- |\n| parent | <code>Object</code> |\n\n<a name=\"module_symbol-tree--SymbolTree+compareTreePosition\"></a>\n\n#### symbolTree.compareTreePosition(left, right) ⇒ <code>Number</code>\nCompare the position of an object relative to another object. A bit set is returned:\n\n<ul>\n    <li>DISCONNECTED : 1</li>\n    <li>PRECEDING : 2</li>\n    <li>FOLLOWING : 4</li>\n    <li>CONTAINS : 8</li>\n    <li>CONTAINED_BY : 16</li>\n</ul>\n\nThe semantics are the same as compareDocumentPosition in DOM, with the exception that\nDISCONNECTED never occurs with any other bit.\n\nwhere `n` and `m` are the amount of ancestors of `left` and `right`;\nwhere `o` is the amount of children of the lowest common ancestor of `left` and `right`:\n\n* `O(n + m + o)` (worst case)\n* `O(n + m)` (amortized, if the tree is not modified)\n\n**Kind**: instance method of <code>[SymbolTree](#exp_module_symbol-tree--SymbolTree)</code>\n\n| Param | Type |\n| --- | --- |\n| left | <code>Object</code> |\n| right | <code>Object</code> |\n\n<a name=\"module_symbol-tree--SymbolTree+remove\"></a>\n\n#### symbolTree.remove(removeObject) ⇒ <code>Object</code>\nRemove the object from this tree.\nHas no effect if already removed.\n\n* `O(1)`\n\n**Kind**: instance method of <code>[SymbolTree](#exp_module_symbol-tree--SymbolTree)</code>\n**Returns**: <code>Object</code> - removeObject\n\n| Param | Type |\n| --- | --- |\n| removeObject | <code>Object</code> |\n\n<a name=\"module_symbol-tree--SymbolTree+insertBefore\"></a>\n\n#### symbolTree.insertBefore(referenceObject, newObject) ⇒ <code>Object</code>\nInsert the given object before the reference object.\n`newObject` is now the previous sibling of `referenceObject`.\n\n* `O(1)`\n\n**Kind**: instance method of <code>[SymbolTree](#exp_module_symbol-tree--SymbolTree)</code>\n**Returns**: <code>Object</code> - newObject\n**Throws**:\n\n- <code>Error</code> If the newObject is already present in this SymbolTree\n\n\n| Param | Type |\n| --- | --- |\n| referenceObject | <code>Object</code> |\n| newObject | <code>Object</code> |\n\n<a name=\"module_symbol-tree--SymbolTree+insertAfter\"></a>\n\n#### symbolTree.insertAfter(referenceObject, newObject) ⇒ <code>Object</code>\nInsert the given object after the reference object.\n`newObject` is now the next sibling of `referenceObject`.\n\n* `O(1)`\n\n**Kind**: instance method of <code>[SymbolTree](#exp_module_symbol-tree--SymbolTree)</code>\n**Returns**: <code>Object</code> - newObject\n**Throws**:\n\n- <code>Error</code> If the newObject is already present in this SymbolTree\n\n\n| Param | Type |\n| --- | --- |\n| referenceObject | <code>Object</code> |\n| newObject | <code>Object</code> |\n\n<a name=\"module_symbol-tree--SymbolTree+prependChild\"></a>\n\n#### symbolTree.prependChild(referenceObject, newObject) ⇒ <code>Object</code>\nInsert the given object as the first child of the given reference object.\n`newObject` is now the first child of `referenceObject`.\n\n* `O(1)`\n\n**Kind**: instance method of <code>[SymbolTree](#exp_module_symbol-tree--SymbolTree)</code>\n**Returns**: <code>Object</code> - newObject\n**Throws**:\n\n- <code>Error</code> If the newObject is already present in this SymbolTree\n\n\n| Param | Type |\n| --- | --- |\n| referenceObject | <code>Object</code> |\n| newObject | <code>Object</code> |\n\n<a name=\"module_symbol-tree--SymbolTree+appendChild\"></a>\n\n#### symbolTree.appendChild(referenceObject, newObject) ⇒ <code>Object</code>\nInsert the given object as the last child of the given reference object.\n`newObject` is now the last child of `referenceObject`.\n\n* `O(1)`\n\n**Kind**: instance method of <code>[SymbolTree](#exp_module_symbol-tree--SymbolTree)</code>\n**Returns**: <code>Object</code> - newObject\n**Throws**:\n\n- <code>Error</code> If the newObject is already present in this SymbolTree\n\n\n| Param | Type |\n| --- | --- |\n| referenceObject | <code>Object</code> |\n| newObject | <code>Object</code> |\n\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/jsdom/js-symbol-tree.git"
  },
  "scripts": {
    "ci": "istanbul cover test/SymbolTree.js --report lcovonly && cat ./coverage/lcov.info | coveralls",
    "documentation": "jsdoc2md --files lib/SymbolTree.js >> README.md",
    "lint": "eslint lib test",
    "postci": "npm run posttest",
    "posttest": "npm run lint",
    "predocumentation": "cp readme-header.md README.md",
    "test": "istanbul cover test/SymbolTree.js"
  },
  "version": "3.2.2"
}
